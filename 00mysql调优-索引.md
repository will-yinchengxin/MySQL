## MySQL 性能调优-索引
> ### 1. 覆盖索引
创建索引的时候尽量使用「覆盖索引」, 5.6 以后的版本支持了「索引下推」, 比如 `select * from table_name where name like "will%" and age = 1`, 覆盖索引为 `index(name, age)` 这里
对 name 值进行筛选后, 不会立即回表, 而是进一步对 age 内容进行筛选, 通过这种 「索引下推」的方式减少了回表的次数, 通过 explain 中 Extra 中的 `Using Index` 即可看出结果

> ### 2. 开启 Mrr 
MRR全称：Multi-Range Read，中文翻译过来就是多范围读取，主要解决的是当二级索引取出索引值后再去聚集索引中取行可能会造成大量的磁盘随机IO的问题

`select * from t3 where a > 100 and a ＜ 500;` 

通过索引肯定会返回一组id的值，如果我们一个id一个id的去找，会很慢。这时候可以对id进行排序，这样会得到一个id的范围，可以范围查找，不用挨个去遍历了，这个过程就叫做MRR

#### MRR优化
MRR优化的目的就是减少磁盘随机IO的产生，其查询优化过程大致如下：

- 先把通过二级索引取出的值缓存在缓冲区中。
- 再把这部分缓冲区中的数据按照ID进行排序。
- 然后再依次根据ID去聚集索引中获取整个数据行。

可以看出，只需要通过一次排序，就使得随机IO，变为顺序IO，使得数据访问更加高效。`read_rnd_buffer_size`控制了数据能放入缓冲区的大小，如果一次性不够放就会分多次完成。

> ### 3. 尽量使用 普通索引 代替 唯一索引

执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点

- 对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。
- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。

##### 为了说明普通索引和唯一索引对更新语句性能的影响这个问题，先跟说下 change buffer。
> 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。
> 需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。
> 将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。
> 显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。

##### 什么条件下可以使用 change buffer 呢？
对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。

`因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。`

change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。

现在，你已经理解了 change buffer 的机制，那么我们再一起来看看如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。

第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB 的处理流程如下：
- 对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。
这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。

但，这不是我们关注的重点。

第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下：
- 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。

`将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。`

> ### 4. 索引走不上
首先考略下我们的 SQL 书写的是否有问题, 比如对索引字段进行了函数操作, 关联查询的时候两个表的编码不一样(工作中有遇到过), 两个比较的字读类型不一致, 比如说 string 和 id 进行
比较, 底层会默认做个隐式转换

再者可能是索引统计的有问题, 通过执行计划 explain, 其实他本身是个随机采样的过程, 可能会选错索引, 对结果有一定影响, 所以他的选择不是最优的, 其实我们可以强制使用索引, 比如
`force index` 但是这种方式只能作为一种备案, 不推荐

##### 最后还是要考略尽量使用 覆盖索引 + 最左匹配原则, 建立合适索引提高性能
